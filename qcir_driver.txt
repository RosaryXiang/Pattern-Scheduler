/**
 * @file qcir-driver.cpp
 * @author 陈铭瑜
 * @brief
 * @version 0.1
 * @date 2022-03-01
 *
 * @copyright Copyright (c) 2022
 *
 */
#include <prettywriter.h>
#include <stringbuffer.h>

#include <fstream>
#include <iostream>
#include <sstream>

#define DEBUG_QVF

#ifdef DEBUG_QVF
#define DEBUG_QVF_INFO(STR) std::cout << STR << std::endl
#define DEBUG_QVF_INFO_PARA(STR, PARA) std::cout << STR << PARA << std::endl
#else
#define DEBUG_QVF_INFO(STR)
#define DEBUG_QVF_INFO_PARA(STR, PARA)
#endif

#include "IR/IRbuilder.h"
#include "IR/Pattern/PatternMatch.h"
#include "IR/QDag.h"
#include "Recognizer/recognizer.h"

#include "Support/DOTGraphTraits.h"
#include "Support/patternScheduler.h"
#include "Support/qasm3_serializer.h"
#include "document.h"

/**
 * @brief 输出帮助信息
 *
 */
void output_help() {
  std::cerr << "Usage: qasm3r_test [-p <pattern-kind>] <input>." << std::endl;
  std::cerr << "Options:" << std::endl;
  ;
  std::cerr << "\t-p <pattern-kind>\t<pattern-kind> is the  " << std::endl;
}

/// 模式库描述文件的相对路径。默认程序的执行位置是在项目根目录下。
// #define Filename "./build/pattern_lib/pattern.json"
// #define Filename
// "/root/Workspace/patopt/qcir_temp/build/pattern_lib/pattern.json"
#define Filename                                                               \
  "/home/jun/桌面/lab/patopt/qcir_temp/build/pattern_lib/quartz_pattern.json"
/*
bool branch_searching(std::shared_ptr<QDag> &qasm_dag,
                      const unsigned long long &father,
                      DagGenericRewriter &rewriter,
                      json::relationshipsReader &schd,
                      json::pattern &largest_pattern) {
  bool matched = false;
  std::stringstream ss;
  DagGenericRewriter rewriter_cp = rewriter;
  std::cout << "father = hash" << std::hex << father << std::endl;
  for (auto &child : schd.relationships[father]) {
    json::patternReader reader;
    ss.str("");
    ss << "hash" << std::hex << child;
    std::cout << "child = " << ss.str() << std::endl;
    reader.getJsonFromFile(Filename, ss.str());
    reader.Json_To_Dag();
    for (auto &pattern : reader.Get_pattern_Vector()) {
      DagGenericRewritePattern rewritePattern(
          pattern.Pair.first->get_dag().get(),
          pattern.Pair.second->get_dag().get());
      if (rewritePattern.matchAndRewrite(qasm_dag.get(), rewriter_cp)) {
        matched = true;
        DagGenericRewriter rewriter_rv = rewriter;
        std::cout << "match is true!!!" << std::endl;
        if (!branch_searching(qasm_dag, child, rewriter_rv, schd,
                              largest_pattern)) {
          largest_pattern = pattern;
          std::cout << "src:" << std::endl;
          std::cout << pattern.Pair.first->toStr() << std::endl;
          std::cout << "dst:" << std::endl;
          std::cout << pattern.Pair.second->toStr() << std::endl;
        }
        break;
      } else {
        std::cout << "fail to match" << std::endl;
      }
    }
    if (matched)
      break;
  }
  std::cout << "match = " << matched << std::endl;
  return matched;
}*/

int main(int argc, char **argv) {
  std::string header = "test";
  bool qasm_to_dag_debug = true;
  bool qvf_debug = false;
  if (argc < 2) {
    std::cerr << "Usage: qasm3r_test [-p <pattern-kind>] <input>." << std::endl;
    return -1;
  } else if (argc > 2) {
    if (strcmp(argv[1], "-p") == 0) {
      if (argc == 4) {
        if (strcmp(argv[2], "debug") == 0)
          header = "test";
        else
          header = argv[2];
      }
    } else {
      output_help();
      return -1;
    }
  }

  std::ifstream input(argv[argc - 1]);
  qasm3::recognizer rcg(input);
  qasm3::error_reporter retporter(std::cerr);
  if (!rcg.execute(retporter)) {
    std::cout << "error\n";
    return 1;
  }

  std::shared_ptr<qasm3::syntax_tree::syntax_tree_node> ast =
      rcg.get_syntax_tree();

  rapidjson::StringBuffer s;
  rapidjson::PrettyWriter<decltype(s)> writer(s);
  qasm3::syntax_tree::qasm3_serializer<decltype(writer)> serializer(writer);
  serializer.serialize(*ast);

  qasm3::IRbuilder ir_builder;
  ir_builder.build(*ast, std::string(argv[1]));
  if (qasm_to_dag_debug) {
    std::cout << ir_builder.getModule()->getCircuit()->get_dag()->toStr()
              << std::endl;
  }
  std::shared_ptr<QDag> qasm_dag =
      ir_builder.getModule()->getCircuit()->get_dag();

#ifdef DEBUG_QVF
  DEBUG_QVF_INFO("\033[32m[Origin DAG]\033[0m");
  std::cout << qasm_dag->toStr() << std::endl;
#endif
  QDagContext *ctx = new QDagContext(qasm_dag);

  json::relationshipsReader rela;
  rela.load_relationship("/home/jun/桌面/lab/patopt/qcir_temp/build/"
                         "pattern_lib/relationship.json");

  // DEBUG_QVF_INFO("\033[32m[rewriter]\033[0m");
  // DagFoldRewriter rewriter(ctx);
  int schedule = 2;
  if (schedule == 0) {
    json::patternReader jsonReader;
    const std::string reader = header;
    jsonReader.getJsonFromFile(Filename, reader);
    jsonReader.Json_To_Dag();

    // DEBUG_QVF_INFO("\033[32m[rewriter]\033[0m");
    // DagFoldRewriter rewriter(ctx);
    int i = 1;
    for (auto &pa : jsonReader.Get_pattern_Vector()) {
      DEBUG_QVF_INFO_PARA("\033[32m[match pattern]\033[0m", i++);
      DagGenericRewritePattern gen_rewriter_pa(pa.Pair.first->get_dag().get(),
                                               pa.Pair.second->get_dag().get());

#ifdef DEBUG_QVF
      DEBUG_QVF_INFO("\033[32m[src]\033[0m");
      gen_rewriter_pa.print_patternDag();
#endif

#ifdef DEBUG_QVF
      DEBUG_QVF_INFO("\033[32m[dst]\033[0m");
      gen_rewriter_pa.print_substDag();
#endif
      DagGenericRewriter gen_rewriter(ctx);
      gen_rewriter_pa.matchAndRewrite(qasm_dag.get(), gen_rewriter);
      std::cout << std::endl;
      DEBUG_QVF_INFO("\033[32m[optimized]\033[0m");
      std::cout << qasm_dag->toStr() << std::endl;
    }
  } else if(schedule == 1){
    DagGenericRewriter rewriter(ctx);
    json::pattern largest_pattern;
    for (auto &f : rela.front_reps) {
      // branch_searching(qasm_dag, f, rewriter, rela, largest_pattern);
    }
  }
  else{
    DagGenericRewriter rewriter(ctx);
    scheduler::inclusionRelaPatternScheduler incluRelaScheduler(rela);
    incluRelaScheduler.initialize(rela.front_reps);
    std::cout << "initial success" << std::endl;
    bool matched_iter = false, matched = false;
    json::pattern largest_pattern;
    int i = 0;
    while (!incluRelaScheduler.empty()) {
      i++;
      std::cout << i << std::endl;
      matched_iter = false;
      const std::unordered_set<std::string> &hash_lists =
          incluRelaScheduler.get_hash_lists();
      std::stringstream ss;
      bool has_break = false;
      for (auto &hash : hash_lists) {
        json::patternReader patt_reader;
        ss.str("");
        ss << "hash"  << hash;
        std::cout << "child = " << ss.str() << std::endl;
        patt_reader.getJsonFromFile(Filename, ss.str());
        patt_reader.Json_To_Dag();
        has_break = false;
        for (auto &patt : patt_reader.Get_pattern_Vector()) {
          DagGenericRewritePattern gen_rewriter_pa(
              patt.Pair.first->get_dag().get(),
              patt.Pair.second->get_dag().get());
          DagGenericRewriter rewriter_cp = rewriter;
          if (gen_rewriter_pa.matchAndRewrite(qasm_dag.get(), rewriter_cp)) {
            if (!matched)
              matched = true;
            incluRelaScheduler.update_hash_lists(hash);
            largest_pattern = patt;
            std::cout << "src:" << std::endl;
            std::cout << patt.Pair.first->toStr() << std::endl;
            std::cout << "dst:" << std::endl;
            std::cout << patt.Pair.second->toStr() << std::endl;
            std::cout << "matched!" << std::endl;
            has_break = true;
            break;
          }
        }
        if(has_break)
          break;
        std::cout << "continue" << std::endl;
      }
      if (!has_break) {
        std::cout << "clear!" << std::endl;
        incluRelaScheduler.clear();
      }
    }
    if (matched) {
      std::cout << "src:" << std::endl;
      std::cout << largest_pattern.Pair.first->toStr() << std::endl;
      std::cout << "dst:" << std::endl;
      std::cout << largest_pattern.Pair.second->toStr() << std::endl;
    } else {
      std::cout << "not matched! " << std::endl;
    }
  }
  // DOTGraphTraits::DOTGraphTraits_impl(*qasm_dag, "./build/output.dot");
  return 0;
}

